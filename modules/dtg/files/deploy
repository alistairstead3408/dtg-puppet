#! /usr/bin/env python2.7

import argparse
import socket
import sys, os
from fabric.api import *
from git import *
import random
import datetime
from datetime import time, timedelta

DTG_DOM = '.dtg.cl.cam.ac.uk'

DOM0    = 'root@husky0' + DTG_DOM
REMOTE_PREFIX = 'lick'

PUPPET_BARE = '/etc/puppet-bare'

SHA_LENGTH = 9

PHYSICAL_MACHINES = [ {'name': 'nas01', 'hostname': 'nas01' + DTG_DOM, 'repo_loc': PUPPET_BARE, 'VM': False},
                      {'name': 'nas04', 'hostname': 'nas04' + DTG_DOM, 'repo_loc': PUPPET_BARE, 'VM': False},
                      {'name': 'entropy', 'hostname': 'entropy' + DTG_DOM, 'repo_loc': PUPPET_BARE, 'VM': False},
                      {'name': 'github', 'hostname': 'git@github.com', 'repo_loc':'ucam-cl-dtg/dtg-puppet.git', 'VM': False},
                      {'name': 'origin', 'hostname': 'git@code.dtg.cl.cam.ac.uk', 'repo_loc': 'infrastructure/dtg-puppet', 'VM': False}
                  ]

class RemoteHandler(RemoteProgress):

    def __init__(self, vm):
        super(RemoteHandler, self).__init__()
        self.vm = vm

    def line_dropped(self, line):
        if (not "Warning: Permanently added" in line) and (line.strip() !=
                                                           "remote:"):
            print("%s: %s" % (self.vm, line))

    def update(self, op_code, cur_count, max_count=None, message=''):
        print(message)


@task
def get_vms():
    uuids = run('xe vm-list params=uuid power-state=running PV-bootloader=pygrub --minimal').split(',')
    vms = []
    for uuid in uuids:
        name_label = run('xe vm-list params=name-label uuid=%s --minimal' % uuid).replace(' ','')
        ip = run('xe vm-param-get param-name=networks uuid=%s | sed -e \'s_0/ip: __\' -e  \'s/; .*$//\'' % uuid)
        try:
            hostname = socket.gethostbyaddr(ip)[0]
        except socket.error:
            sys.stderr.write("Unable to lookup hostname of %s\n" % name_label)
            continue

        vms.append({'name':name_label, 'hostname':hostname, 'repo_loc': PUPPET_BARE, 'VM': True, 'uuid':uuid})
    # Randomize the order of vms. Otherwise we will starve the vms at the end of the list
    # if lick doesn't finish running
    random.shuffle(vms)
    return vms

def get_machines():
    vms = execute(get_vms, hosts=[DOM0])
    return vms[DOM0] + PHYSICAL_MACHINES

@task
def snapshot_mc(mc, commit_id):
    assert mc['VM']

    new_snap_name = commit_id[0:SHA_LENGTH]
    cur_snaps = run('xe snapshot-list  snapshot-of=%s params=name-label --minimal' % mc['uuid']).split(',')
    if new_snap_name in cur_snaps:
        print('%s already has a snapshot for commit %s. Not snapshotting again' % (mc['name'], new_snap_name))
    else:
        print('Snapshotting %s' % mc['name'])
        run('xe vm-snapshot uuid=%s new-name-label=%s' % (mc['uuid'], new_snap_name))

def is_hex(str):
    try:
        int(str, 16)
    except ValueError:
        return False
    return True

@task
def snap_gc():
    snap_uuids = run('xe snapshot-list params=uuid --minimal').split(',')
    snap_names = run('xe snapshot-list params=name-label --minimal').split(',')
    snap_times = run('xe snapshot-list params=snapshot-time --minimal').split(',')
    snap_times = map(lambda x:
                     datetime.datetime.strptime(x, '%Y%m%dT%H:%M:%SZ'),
                     snap_times)
    keys = ('uuid', 'name', 'time')
    snaps = ([dict(zip(keys, data)) for data in
              zip(snap_uuids, snap_names, snap_times)])

    # filter out those snapshots where the timestamp field is > 14 days old
    snaps = filter(lambda x: x['time'] <
                   datetime.datetime.today() - timedelta(days=14), snaps)

    # filter out snapshots whose name is not $SHA_LENGTH digits of hex
    snaps = filter (lambda x: is_hex(x['name']) and
                    len(x['name']) == SHA_LENGTH, snaps)

    if snaps:
        print('Destroying %d old snapshots' % len(snaps))

    for snap in snaps:
        run('xe snapshot-uninstall force=true uuid=%s' % snap['uuid'])


@task
def upgrade_mc():
    # Remove unusued packages to reduce the chance of falling over
    # during the upgrade
    with show('output'):
        sudo('apt-get -y dist-upgrade')
        sudo('apt-get -y autoremove')
        sudo('rm -rf /etc/apt/sources.list.d/*.{save,distUpgrade}')
        sudo("sed -i 's/Prompt=lts/Prompt=normal/' /etc/update-manager/release-upgrades")
        sudo('do-release-upgrade -f DistUpgradeViewNonInteractive')

@task
def security_update():
    sudo('apt-get update')
    sudo('unattended-upgrade')


def run_puppet():
    with show('output'):
        with cd('/etc/puppet'):
            run('sudo -H puppet apply --verbose --modulepath modules manifests/site.pp')

@task
def post_update_hook():
    run('/etc/puppet-bare/hooks/post-update')

def add_remotes(repo, machines):
    """
    Delete all remotes, then add those listed in `machines'
    """
    for remote in repo.remotes:
        if (remote.name.startswith(REMOTE_PREFIX)):
            repo.delete_remote(remote)
    for mc in machines:
        repo.create_remote(REMOTE_PREFIX + '_' + mc['name'], mc['hostname']  + ':' + mc['repo_loc'])

def push_config(repo, mc, upgrade, sec_update):
    if mc['VM']:
        execute(snapshot_mc, mc, repo.head.commit.hexsha, hosts=[DOM0])
    if upgrade:
        execute(upgrade_mc, hosts=[mc['hostname']])
    if sec_update:
        execute(security_update, hosts=[mc['hostname']])
    print('Pushing to %s' % mc['name'])
    handler = RemoteHandler(mc['name'])
    remote = repo.remotes[REMOTE_PREFIX + '_' + mc['name']]
    info = remote.push(refspec='master:master', progress=handler)[0]
    execute(run_puppet, hosts=[mc['hostname']])
    if info.flags & (info.NEW_TAG | info.NEW_HEAD |
                     info.UP_TO_DATE | info.FAST_FORWARD):
        print(info.summary)
    else:
        sys.stderr.write(info.summary)
        sys.stderr.write("Incorrect flag whilst pushing to %s: %d. Terminating.\n"
                         % (mc['name'], info.flags))
        sys.exit(-1)


def main(args):
    output['running'] = False
    output['stdout'] = False
    ssh_no_fngr =  "%s/%s" % (os.getcwd(), 'ssh-no-fingerprint')
    try:
        with open(ssh_no_fngr): pass
    except IOError:
        sys.stderr.write('You must lick from modules/dtg/files')
        sys.exit(1)

    env.warn_only = True

    repo = Repo('.')
    machines = get_machines()
    add_remotes(repo, machines)

    if args.machines:
        machines = filter(lambda m : m['name'] in args.machines, machines)
    if not machines:
        sys.stderr.write("No machines to apply puppet to")
        sys.exit(-1)

    # Remove old lick-generated snapshots, or else they build up
    if not args.no_snap_gc:
        execute(snap_gc, hosts=[DOM0])

    # Set GIT_SSH to point to the wrapper around SSH that stops hostkey checks.
    # We don't need to check hostkeys as we're only pushing at hosts, so we don't care if someone MiTMs us.
    os.environ['GIT_SSH'] = ssh_no_fngr

    for mc in machines:
        try:
            push_config(repo, mc, args.upgrade, args.security_update)
        except GitCommandError:
            sys.stderr.write('Cannot push to %s' % mc['name'])

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Pushes the master branch of dtg-puppet, as found on github all over the world')
    parser.add_argument('--boot', help='Boot linux machines that are currently turned off.')
    parser.add_argument('--do-release-upgrade', action='store_true', dest='upgrade', help='Upgrade the version of Ubuntu before applying the puppet config')
    parser.add_argument('--no-snap-gc', action='store_true', dest='no_snap_gc', help='Do not remove old snapshots')
    parser.add_argument('--security-update', action='store_true', dest='security_update', help='Apply all security updates immediately')
    parser.add_argument('machines', nargs='?', help='Limit the machines that the lick is applied to')

    args = parser.parse_args()
    main(args)
